# 关键字
## 基本类型
char byte short int long double float boolean 

类型 | char | byte | short | int | long | double | float | boolean |
-- | -- |-- | -- | -- | -- | -- | -- | -- | 
长度(字节) | 2(Unicode) | 1 | 2 | 4 | 4 | 8 | 4 | 8 |

### 面试题目总结
1. 类型转换
    ```java
    short a = 1;
    a += 1; // 不报错，因为编译器会进行转换处理
    a = a + 1;  // 报错，a + 1运算过程中会把a强制转换为int类型，结果也为int类型，赋值给a会出先类型转换错误
    float f = 3.4 // 错误，3.4 是double类型，需要强转或者3.4f
    ```
    char byte short 在运算过程中都会被强制转换为int类型

2. java中char能够存储汉字吗?
能。java中char类型存储的是Unicode字符，但是生僻的汉字可能无法存储。
3. 基本类型和包装类型

4. switch能够作用在byte,long,String上？
switch可以作用的类型为char,int,short,byte以及对应的包装类型，String,enum等。其中char,short,byte会转换为int

5. 能否不进行强制转换将double转换为long？
不能。double范围更广。

6. double
```java
if(3 * 0.1 == 3.0) { // false,double会损失精度，可以用BigDicimal类型进行浮点数判断

}
BigDecimal value = BigDecimal.valueOf(0.1);
value = value.multiply(3);
int result = value.compareTo(BigDecimal.valueOf(0.3)); //result = 0
```

## 字符串
String StringBuffer StringBuilder

## 集合
Array Collection 
### 链表
List ArrayList LinkedList Vector 
类型 | 底层 | 容量满后的增长机制 | 优势 | 劣势| 线程安全 |
-- | -- | -- | -- | -- | -- |
ArrayList | 数组 | 50% | 查询遍历快 | 删除插入慢 | 否 |
LinkedList | 链表 | 容量无限制 | 删除插入块 | 查询遍历慢 | 否 |
Vector | 数组 | 100% | 同ArrayList | 同ArrayList | 是 | 

#### 面试问题
1. 如何实现线程安全的List？
* Collections.sychonizedList(List<> list)
读慢写块
* CopyOnWriteArrayList()
写特别慢读快
2. List排序
Collections.sort();
3. Collections.asList() 返回的List可以被修改吗？
不能 是final类型的,不能add和扩容

### 堆
Set HashSet TreeSet LinkedHashSet heap
类别 | 底层数据结构 | 插入顺序 | 值顺序 | 
-- | -- | -- | -- |
HashSet | HashMap | 无序 | 无序 | 
TreeSet | TreeMap | 无序 | Comparableor Comparator |
LinkedHashSet | HashMap | 有序 | 无序 | 

### Map
Map HashMap TreeMap LinkedHashMap ConcurrentHashMap 
* 面试题
    1. HashMap，ConcurrentHashMap底层原理
### 栈
stack
### 队列
queue LinkedList ConcurrentLinkedList PriorityQueue ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue Dequeue

## 多线程
synchronized volatile run start thread 
* synchronized 
    1. 在语言层次上是怎么实现的？
    利用javap可以将class文件反编译可以看到，synchronized修饰方法是会生成ACC_SYNCHRONIZED 标记，修饰代码块时会生成monitorenter,monitorexit标记。每一个java类的对象，JVM都会安排一个object monitor去监视该对象，如果一个线程执行到了synchronized修饰的地方，monitor的结构体中会记录下该线程的id，将表示当前对象已经有线程访问，并且给改代码块上锁，其它线程访问的时候，发现已经有线程在使用，就不会允许访问。最后当前线程执行经过monitorexit，monitor会释放该锁。

    2. 如何保证线程安全？
    原子性、可见性、有序性

## 序列化
transient
## 多态
implements extends this super 
### 面试题
* 接口相对于抽象类的优势在哪里？
    1. 现有的类很容易被更新，直接定义一个接口然后implements就行了
    2. 可以实现混合类型(mixin)。比如Comparable，继承Comparable的类就可以进行排序。支持类添加任选的功能可以被混合到类型的主要功能中
    3. 构造非层次结构的类型框架，比如有三个接口分别实现了三个工能，有些类可能需要其中的一个，两个或三个，如果用抽象类实现，就要实现2^N种情况，这称为组合爆炸。

## 类
public private protected default static final const

## 异常
throw throws try catch finally 

## 反射
instanceof
### instanceof 底层实现
1. 映射到JVM的instanceof操作
## 其他
enum break continue 
* enum 

# 数据结构
## 队列、栈、链表
### 队列
* 方法
    * add 队列满则抛出异常
    * put 队列满则阻塞
    * offer 队列满则返回false
    * peek 空则返回null
    * take 空则阻塞

* 非阻塞
    * LinkedList
    * ConcurrentLinkedQueue

* 阻塞
    * LinkedBlockingQueue
    * ArrayBlockingQueue
    * LinkedBlockDequeue
    双向,newSingleThreadExecutor()和newFixedThreadExecutor()
    * PriorityQueue
    优先队列
    * DelayQueue
    经过一定时间才能够出队列
    * SynchronousQueue
    无缓冲队列, newCacheThreadExecutor()

### 栈
* 方法
    * push
    * pop
    * peek

### 链表
* ArrayList
* LinkedList
* Vector

## 什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）

## 栈和队列的相同和不同之处 

## 栈通常采用的两种存储结构 

## 两个栈实现队列，和两个队列实现栈

# 算法
## 排序都有哪几种方法？
## 会写常用的排序算法，如快排，归并等。
## 各种排序算法的时间复杂度和稳定性 ，重点快排。
## 单链表的遍历和逆序 
## 深度优先搜索和广度优先搜索
## 最小生成树
## 常见Hash算法，哈希的原理和代价
## 全排列、贪心算法、KMP算法、hash算法
## 一致性Hash算法

# 操作系统
# 虚拟内存管理 
