# 关键字
## 基本类型
char byte short int long double float boolean 

类型 | char | byte | short | int | long | double | float | boolean |
-- | -- |-- | -- | -- | -- | -- | -- | -- | 
长度(字节) | 2(Unicode) | 1 | 2 | 4 | 4 | 8 | 4 | 8 |

### 面试题目总结
1. 类型转换
    ```java
    short a = 1;
    a += 1; // 不报错，因为编译器会进行转换处理
    a = a + 1;  // 报错，a + 1运算过程中会把a强制转换为int类型，结果也为int类型，赋值给a会出先类型转换错误
    float f = 3.4 // 错误，3.4 是double类型，需要强转或者3.4f
    ```
    char byte short 在运算过程中都会被强制转换为int类型

2. java中char能够存储汉字吗?
能。java中char类型存储的是Unicode字符，但是生僻的汉字可能无法存储。
3. 基本类型和包装类型

4. switch能够作用在byte,long,String上？
switch可以作用的类型为char,int,short,byte以及对应的包装类型，String,enum等。其中char,short,byte会转换为int

5. 能否不进行强制转换将double转换为long？
不能。double范围更广。

6. double
```java
if(3 * 0.1 == 3.0) { // false,double会损失精度，可以用BigDicimal类型进行浮点数判断

}
BigDecimal value = BigDecimal.valueOf(0.1);
value = value.multiply(3);
int result = value.compareTo(BigDecimal.valueOf(0.3)); //result = 0
```

## 字符串
String StringBuffer StringBuilder

## 集合
Array Collection 
### 链表
List ArrayList LinkedList Vector 
类型 | 底层 | 容量满后的增长机制 | 优势 | 劣势| 线程安全 |
-- | -- | -- | -- | -- | -- |
ArrayList | 数组 | 50% | 查询遍历快 | 删除插入慢 | 否 |
LinkedList | 链表 | 容量无限制 | 删除插入块 | 查询遍历慢 | 否 |
Vector | 数组 | 100% | 同ArrayList | 同ArrayList | 是 | 

#### 面试问题
1. 如何实现线程安全的List？
* Collections.sychonizedList(List<> list)
读慢写块
* CopyOnWriteArrayList()
写特别慢读快
2. List排序
Collections.sort();
3. Collections.asList() 返回的List可以被修改吗？
不能 是final类型的,不能add和扩容

### 堆
Set HashSet TreeSet LinkedHashSet heap
类别 | 底层数据结构 | 插入顺序 | 值顺序 | 
-- | -- | -- | -- |
HashSet | HashMap | 无序 | 无序 | 
TreeSet | TreeMap | 无序 | Comparableor Comparator |
LinkedHashSet | HashMap | 有序 | 无序 | 

### Map
Map HashMap TreeMap LinkedHashMap ConcurrentHashMap 
* 面试题
    1. HashMap，ConcurrentHashMap底层原理
### 栈
stack
### 队列
queue LinkedList ConcurrentLinkedList PriorityQueue ArrayBlockingQueue LinkedBlockingQueue SynchronousQueue Dequeue

## 多线程
synchronized volatile run start thread 
* synchronized 
    1. 在语言层次上是怎么实现的？
    利用javap可以将class文件反编译可以看到，synchronized修饰方法是会生成ACC_SYNCHRONIZED 标记，修饰代码块时会生成monitorenter,monitorexit标记。每一个java类的对象，JVM都会安排一个object monitor去监视该对象，如果一个线程执行到了synchronized修饰的地方，monitor的结构体中会记录下该线程的id，将表示当前对象已经有线程访问，并且给改代码块上锁，其它线程访问的时候，发现已经有线程在使用，就不会允许访问。最后当前线程执行经过monitorexit，monitor会释放该锁。

    2. 如何保证线程安全？
    原子性、可见性、有序性

## 序列化
transient
## 多态
implements extends this super 
### 面试题
* 接口相对于抽象类的优势在哪里？
    1. 现有的类很容易被更新，直接定义一个接口然后implements就行了
    2. 可以实现混合类型(mixin)。比如Comparable，继承Comparable的类就可以进行排序。支持类添加任选的功能可以被混合到类型的主要功能中
    3. 构造非层次结构的类型框架，比如有三个接口分别实现了三个工能，有些类可能需要其中的一个，两个或三个，如果用抽象类实现，就要实现2^N种情况，这称为组合爆炸。

## 类
public private protected default static final const

## 异常
throw throws try catch finally 

## 反射
instanceof
### instanceof 底层实现
1. 映射到JVM的instanceof操作
## 其他
enum break continue 
* enum 

# 计算机基础知识
## 数据结构
### 队列、栈、链表
#### 队列
* 方法
    * add 队列满则抛出异常
    * put 队列满则阻塞
    * offer 队列满则返回false
    * peek 空则返回null
    * take 空则阻塞

* 非阻塞
    * LinkedList
    * ConcurrentLinkedQueue

* 阻塞
    * LinkedBlockingQueue
    newSingleThreadExecutor()和newFixedThreadExecutor()
    * ArrayBlockingQueue
    * LinkedBlockDequeue
    双向
    * PriorityQueue
    优先队列
    * DelayQueue
    经过一定时间才能够出队列
    * SynchronousQueue
    无缓冲队列, newCacheThreadExecutor()

#### 栈
* 方法
    * push
    * pop
    * peek

#### 链表
* ArrayList
* LinkedList
* Vector

### 什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）

### 栈和队列的相同和不同之处 

### 栈通常采用的两种存储结构 

### 两个栈实现队列，和两个队列实现栈

## 算法
### 排序都有哪几种方法？
### 会写常用的排序算法，如快排，归并等。
### 各种排序算法的时间复杂度和稳定性 ，重点快排。
### 单链表的遍历和逆序 
### 深度优先搜索和广度优先搜索
### 最小生成树
### 常见Hash算法，哈希的原理和代价
### 全排列、贪心算法、KMP算法、hash算法
### 一致性Hash算法

## 操作系统
## 虚拟内存管理 

# java基础
## 封装、继承、多态

## 集合相关

## 异常相关

## 其他

# java高级
## 多线程
1. 进程和线程的区别
    * 进程是系统资源分配的基本单位，线程是CPU计算的基本单位
    * 进程包含一个或多个线程
    * 进程之间通信比较麻烦，需要通过消息队列、管道、FIFO、共享内存、信号量等方式，线程间通信可以通过共享内存。
    * java进程间通信可以通过Socket、RPC、消息队列等技术

2. 并行(Parallelism)和并发(Concurrency)的区别与联系
    * 并行是两个或多个事件在同一时刻发生，并发是两个或多个事件在同一个时间间隔发生
    * 并行是多个事件作用于不同的实体，并发是多个事件作用于同一个实体

3. 同步与异步，阻塞和非阻塞
    * 同步和异步主要关注的是结果获取方式，异步通过回调函数获取结果。
        * 同步：发出请求，一直等待结果返回。
        * 异步：发出请求，直接返回，由接受请求的一方主动通知请求放。
    * 阻塞和非阻塞关注请求方的状态
        * 阻塞：请求方再有结果之前一直 **等待** 。
        * 非阻塞：请求方再有结果之前可以做别的事情，但要 **时不时的查看结果出来了没**。

    老张爱喝茶，废话不说，煮开水。
    出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
    1. 老张把水壶放到火上，立等水开。（同步阻塞）
    老张觉得自己有点傻
    2. 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）
    老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。
    3. 老张把响水壶放到火上，立等水开。（异步阻塞）
    老张觉得这样傻等意义不大
    4. 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）
    老张觉得自己聪明了。

    所谓同步异步，只是对于水壶而言。
    普通水壶，同步；响水壶，异步。
    虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。
    所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。
    ——来源网络，作者不明。

4. 多线程的实现方式，有什么区别？
    * Thread
    类
    * Runnable
    无返回值
    * Callable
    有返回值，FutureTask
    * 线程池
    ExecutorService

5. 什么叫守护线程？
    * java线程分为User thread和Daemon thread
    * Daemon thread本质上和User thread没有区别
    * Daemon thread为JVM中所有其他线程提供服务的，只要有一个非守护线程没退出，Daemon就不会推出

6. 如何停止一个线程？
    * stop方法
        stop()强制推出当前线程，不安全，不建议使用。
    * 在run函数中判断isInterrupted(),外部调用interrupt()方法
        ```java
        public class TreadTest extends Thread {
            
            @Override
            public void run() {
                while(!isInterrupted()) {
                    System.out.println("Thread is running");
                }
                System.out.println("Thread is stopped.");
            }
            public static void main(String[] args) {
                ThreadTest test = new ThreadTest();
                test.start();
                test.interrupt();
            }
        }

        ```

    * 定义一个boolean类型的变量表示是否停止，run函数中进行判断
        ```java
        public class TreadTest extends Thread {
            private boolean running = false;
            
            @Override
            public void run() {
                running = true;
                while(running) {
                    System.out.println("Thread is running");
                }
                System.out.println("Thread is stopped.");
            }

            public void stop() {
                this.running = false;
            }

            public static void main(String[] args) {
                ThreadTest test = new ThreadTest();
                test.start();
                test.stop();
            }
        }

        ```
7. 什么是线程安全？
    线程安全发生在有多个线程共同修改某个资源的时候。当某个线程修改了某个变量，其它线程在修改前该变量的值必须是最新的。
    当某个操作由多个线程执行的结果与单个线程执行的结果相同，那么就可以说这个操作是线程安全的。

8. synchronized和lock的区别
    * synchronized是java的关键字，是由JVM实现的；lock是java.util.concurrent中的类，是由JDK实现的。
    * synchronized无法实现公平锁，lock可以实现
    * synchronized代码块结束后自动释放锁，lock需要手动释放
    * lock粒度更细

9. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
    可以进入非synchronized的方法

10. 启动一个线程是用run()还是start()? 
    start()

11. wait和sleep的区别
    * 进程状态：新建(new start)，就绪(runnable)，运行(running)，阻塞(blocked)，死亡(dead)
    * wait()作用是暂停当前线程，其他线程调用notify()或者notifyAll()函数后继续执行当前线程
    * wait()是Object方法，sleep()是Thread类的静态方法
    * wait()会释放锁，sleep()不会
    * sleep()需要指定休眠时间(毫秒)参数

12. notify()和notifyAll()的区别
    * notify()只唤醒一个线程，如果有多个线程取决于操作系统
    * notifyAll()唤醒所有线程

13. 线程池的作用
    用户只需要提交任务，具体的任务调度，由线程池操作。
    1. 提高资源利用率
    线程池可以重复利用已经创建好的线程
    2. 提高响应速度
    newFixedThreadPool在线程数没达到上限时，添加一个任务开启一个线程，达到上限后，之前的任务执行完毕，新加的任务不需要创建新的线程就可以直接执行。
    3. 具有可管理性
    进程池根据当前系统特点对池内线程优化处理，减少创建和销毁线程带来的开销。

    * 应用场景
        1. 任务执行时间段
        2. 任务量大

14. java线程池相关的类
```java
ExecutorService executor = Executors.newFixedThreadPool(10);
executor = Executors.newSingleThreadPool();
executor = Executors.newCachedThreadPool();
executor = Executors.newScheduledThreadPool();
ThreadPoolExecutor
```


## JVM底层技术
1. gc的概念，如果A和B对象循环引用，是否可以被GC？ 
    * 垃圾回收(Gabage Collection)。java创建的对象需要占用堆中的内存，当对象的生命周期结束后，这些对象就成了垃圾，JVM会回收这些垃圾。
    * 可以被回收，回收算法有两种：引用计数法和根搜索法。引用计数法无法解决AB循环引用的问题，根搜索法可以。
    * 根搜索算法，root判定主要有以下三种：
        * 虚拟机栈中的引用对象
        * 方法区中类静态属性引用的对象
        * 方法区中常量引用的对象
        * 本地方发栈中JNI(native方法)引用的对象
    

2. jvm gc如何判断对象是否需要回收，有哪几种方式？



## IO
